\chapter{Вычислительные аспекты проблемы перечисления разбиений}


%Задача перечисления разбиений прямоугольника заданных целочисленных размеров $h\times w$ на прямоугольники $1\times 2$ рассматривалась рядом авторов в связи с вопросами термодинамики потоков жидкости и проблемой перечисления совершенных паросочетаний плоского графа за полиномиальное время.

%Но все известные формулы решения задачи используют действия с плавающей запятой, что  сопряжено с проблемами округления; исключение составляет лишь полученная в известной монографии Д. Кнута и др. для случая $w=3$ система из двух взаимно-рекуррентных формул, использующая только операции сложения целых чисел.

%В разделе 1 разработан алгоритм, компьютерное воплощение которого способно для искомого перечисления разбиений прямоугольника сгенерировать систему взаимно-рекуррентных формул, использующих лишь операции сложения целых чисел и, таким образом, свободных от проблем округления вещественных чисел.


%\section{Введение}



Через $M(h\times w)$ будем обозначать прямоугольник $M$ размеров $w$ и $h$, а количество его разбиений на $1\times 2$-прямоугольники (\textit{ плитки}) --- через $f(h,w)$.
Задача перечисления разбиений заданного прямоугольника на плитки впервые рассмотрена в работах \cite{akm_2,akm_3} в связи с вопросами термодинамики потоков жидкости. Отметим также, что различным аспектам этой задачи посвящена и значительная часть главы 7 книг \cite{akm_6} и \cite{akm_7}, где, в частности, рассмотрена задача построения \textit{ взаимно-рекуррентных} формул (в.р.ф.) для $f(h,w)$ при $w=2$ и $w=3$. Полученную в этих работах формулу приведем в обозначениях данной статьи:
\begin{equation}\label{eq01}
f(h,w)=2^{\frac{wh}{2}}\prod_{j=1}^{w} \prod_{k=1}^{h}
\left(
\cos^2{\frac{\pi j}{w+1}}
+\cos^2{\frac{\pi k}{h+1}}
\right)^{1/4}.
\end{equation}
С вычислительной точки зрения формула \eqref{eq01} обладает тем недостатком, что действия с плавающей запятой неизбежно сопряжены с приближенным характером вычислений. Например, вычисления, выполненные по формуле \eqref{eq01} программой C\# с применением двойной точности, приводят к неверным значениям: $f(68,2)=117669030460993$, $f(16,8)=540061286536919$, $f(15,5)=3$ и $f(11,9)=3812$, тогда как истинные значения равны: $f(68,2)=117669030460994$, $f(16,8)=540061286536921$, $f(15,5)=0$ и $f(11,9)=0$ соответственно. Таким образом, формула \eqref{eq01} малопригодна для точного решения перечислительной задачи при значительных размерах прямоугольника.
Цель данного раздела заключается в построении системы в.р.ф., использующих лишь операции сложения целых чисел, более точно, в формулировке алгоритма компьютерной генерации таких формул.

\section{Построение системы в.р.ф.}

Из двух параметров $w$ и $h$ примем $w$ за основной; тогда при каждом фиксированном $w$ искомые рекуррентные формулы будут зависеть лишь от $h$.
Следующие утверждения очевидны: а) $f(h,w)=0$, если и только если произведение $w\cdot h$ нечетно, б) $f(h,1)=1$ при четном $h$. При небольших значениях $w$ вывод формул для $f(h,w)$ \textit{ вручную}, без привлечения компьютера, не представляет трудности. Легко видеть, например, что при $w=2$ значения $f(h,w)$ задаются числами Фибоначчи:
$$
f(1,2)=1,\ f(2,2)=2;\ f(h,2)=f(h-1,2)+f(h-2,2) \text { при }  h>2.
$$
%\end{document}
Однако вывод в.р.ф. вручную представляется малореальным уже при значениях $w$, близких к $10$, и вовсе невыполнимым при больших $w$; достаточно сказать, что при ${w=13}$ количество $Q(w)$ формул в системе в.р.ф., сгенерированных авторским программным обеспечением, оказалось равно $3050$.

Если положить \textit{ начальной клеткой} <<горизонтальной>> плитки ее левую клетку, а начальной клеткой <<вертикальной>> плитки --– верхнюю клетку плитки, то упорядочение клеток исходного прямоугольника <<по строкам>>:
\begin{equation}\label{eq02}
M_{11}, ..., M_{1w}, ..., M_{h1},..., M_{hw}
\end{equation}
естественным образом задает упорядочение плиток в каждом \textit{ полном разбиении} (т.е. в таком разбиении на плитки, когда каждая клетка прямоугольника принадлежит в точности одной плитке, и наоборот --- обе клетки каждой плитки принадлежит прямоугольнику). Для этого достаточно из двух плиток считать предшествующей ту плитку, чья начальная клетка располагается раньше в упорядочении <<по строкам>>; для соответствующего упорядочения плиток в полном разбиении также будем применять термин <<по строкам>>.

Понятие \textit{ частичного разбиения} (ч.р.) прямоугольника определяется рекурсивно. \textit{ Пустое покрытие} (когда не уложена ни одна плитка) будем считать частичным разбиением и обозначать $\mu_{11}$;
ячейку $M_{ij}$ будем называть \textit{ клеткой ветвления ч.р.}, если выполнены следующие два условия:
1) $M_{ij}$ является первой клеткой прямоугольника в последовательности \eqref{eq02}, не покрытой плитками; 2) клетки $M_{ij}$, $M_{i,j+1}$  и $M_{i+1,j}$ существуют (т.е. принадлежат прямоугольнику) и не покрыты плитками;

если $\mu_{ij}$ --- ч.р. с клеткой ветвления $M_{ij}$, то наименьшее разбиение, содержащее $\mu_{ij}$ и одну из двух пар клеток --- $(M_{ij}$, $M_{i+1,j})$ либо $(M_{ij}, M_{i,j+1})$ --- считается частичным разбиением --- потомком ч.р. $\mu_{ij}$, если обладает клеткой ветвления или же равно полному разбиению.
По отношению к клетке прямоугольника, частично или полностью разбитого на плитки, удобно использовать термины <<закрашена>>/<<не закрашена>> в зависимости от того, покрыта или непокрыта она некоторой плиткой.

Для ч.р. удобно называть занятую плитками часть прямоугольника \textit{ закрашенной фигурой}, а оставшуюся часть --- не закрашенной или \textit{ светлой фигурой}. Поскольку в перечислении разбиений без ограничения общности можно применять способ укладки плиток <<по строкам>>, в любом ч.р. закрашенной фигурой будет верхняя, а светлой --- нижняя фигура. В этих терминах, первая незакрашенная клетка ч.р. называется \textit{ клеткой ветвления}, если ее правая и нижняя соседние клетки не закрашены.

Полный перебор разбиений прямоугольника $M(h\times w)$ будем рассматривать как процесс построения двоичного ориентированного дерева.
\par\smallskip
\underline{Метод северо-западной клетки}

1. Соотнесем корневую вершину дерева пустому разбиению $\mu_{11}$ . Легко видеть, что клеткой ветвления корневой вершины является $M_{11}$.

2. Выполним последовательное рассмотрение и нумерацию листьев уровней $0,1,\dots$: пока существует лист дерева, отличный от полного разбиения, для каждого такого листа --- ч.р. $v$ включим клетку ветвления в добавляемую в ч.р. плитку --- горизонтальную или вертикальную --- и продолжим отдельно каждое из двух полученных разбиений до получения потомка ч.р. $v$.

\underline{Конец алгоритма}
\par\smallskip
Построенное методом северо-западной клетки двоичное дерево будем называть \textit{  полным двоичным деревом}. Рассматривая упорядоченность плиток полного разбиения <<по строкам>> в качестве хронологической последовательности укладки плиток, получим следующее утверждение.

\label{the2}
Набор листьев полного двоичного дерева задает набор всех полных разбиений.


\begin{remark} Удобно использовать одно и то же обозначение для ч.р. и соответствующей ему вершины полного двоичного дерева.
\end{remark}
Каждому ч.р. $v$ сопоставим \textit{ дескриптор} $(v_1,...,v_w)$, где
$$
v_k  = h-max\{i: M_{ik}\in v; k=1,\dots, w\}
$$
и индекс $ind_v= \max\{v_1,...,v_w\}$. Вектор
$$\{v_k-\min\{v_1,\dots,v_w\};\ 1\leq k\leq w\}$$
будем называть \textit{ нормализованным дескриптором} $v$. Другими словами, \textit{ дескриптор ч.р.} --- это вектор, элементы которого --- суть высоты столбцов светлой фигуры ч.р., а \textit{ индекс ч.р.} --- наибольшее значение этих высот.
\begin {remark} Если придерживаться способа уложения плиток <<по строкам>>, то элементы нормализованного дескриптора любого ч.р. принадлежат множеству $\{0, 1, 2\}$.
\end{remark}
Для ч.р. $v$ обозначим через $\varphi(v)$ количество способов достройки $v$ до полного разбиения. Если $x$ и $y$ являются непосредственными потомками вершины $v$, то
\begin{equation}\label{eq03}
\varphi(v)=\varphi(x)+\varphi(y).
\end{equation}
Очевидно, что $\varphi(v)$ определяется нормализованным дескриптором ч.р. $v$ и $ind_v$.
Рассмотрим двоичное поддерево, полученное в результате выполнения нескольких начальных шагов методом северо-западной клетки. Вершины с дескрипторами
$$
(v_1,...,v_w), (v_w,...,v_1) \text{ и }  (v_1  + C,...,v_w  + C),
\text{ где } C = const,
$$
будем называть \textit{ эквивалентными}.

Выполним разбиение множества всех вершин на классы эквивалентности: $F[0], F[1], \dots$.

Количество различных способов достройки ч.р. $v$ (вершины дерева), принадлежащей $F[i]$, до полного разбиения будем называть \textit{ перечислением для вершины $v$} и обозначать $F[i,ind_v]$.

Лист $v$, полученный на некотором шаге метода северо-западной клетки, будем называть \textit{ терминальной вершиной}, если в момент создания $v$ уже существует эквивалентная ей вершина $v'$ степени больше единицы; при этом вершину $v'$ будем называть \textit{ вторичной терминальной вершиной}.  Наблюдение <<начало поддерева с корнем в вершине $v$ будет в точности таким же, как и начало поддерева с корнем в вершине $v'$>> служит основой для генерации взаимно-рекуррентных формул.

Условимся прервать метод северо-западной клетки, когда все листья построенной части дерева являются терминальными вершинами; построенное вплоть до прерывания дерево будем называть \textit{ элиминированным двоичным деревом}.

\label{the3}
Для каждой вершины $v$  $i$-го уровня двоичного дерева и ${w\leq i}$ найдется такой уровень $j$, что  $i-w\leq j\leq i+w$ и $j$-й уровень содержит вершину, эквивалентную вершине $v$.


Пусть $v$ является вторичной терминальной вершиной элиминированного двоичного дерева. Двоичное поддерево $T_v$   с корнем в вершине $v$ будем называть \textit{ терминальным}, если среди его вершин терминальными являются только корень и листья.

\label{the4}
Перечисление для вторичной терминальной вершины $v$ равно сумме перечислений для листьев терминального поддерева $T_v$.

\underline{Алгоритм <<Перечисление по терминальным поддеревьям>>}

1) из каждого класса эквивалентности $F[i]$ выбрать по одной вторичной терминальной вершине $v$;
2) построить терминальное поддерево $T_v$  и представить перечисление $F[i,ind_v]$ в виде суммы перечислений для листьев терминального поддерева $T_v$.

\underline{Конец алгоритма}
\label{the5}

Алгоритм <<Перечисление по терминальным поддеревьям>> формирует в.р.ф. для решения задачи перечисления разбиений $M(h\times w)$.

Пусть элиминированное двоичное дерево построено. Обозначим искомое множество в.р.ф. через $R$, а множество терминальных вершин, включающее точно одного (произвольно выбранного) представителя из каждого класса эквивалентности, --- через $N$. Сначала каждой вершине из $N$ присвоим метки вида:
$$F[\text{номер класса эквивалентности, индекс}]$$,
затем по алгоритму <<Перечисление по терминальным поддеревьям>> сгенерируем искомое множество $R$.

Авторское программное сопровождение состоит из трех частей. В первой реализован алгоритм <<Перечисление по терминальным поддеревьям>>, а также сконструированы нормализованные дескрипторы вершин множества $N$ для передачи второй части. Во второй части выполняется инициализация начальных значений в.р.ф. для каждого из нормализованных дескрипторов, вычисленных в первой части. Третья часть предназначена для выполнения расчетов в соответствии с в.р.ф., сгенерированными в первой части, и значениями их начальных элементов, вычисленных во второй части. Отметим, что расчеты выполняются с использованием многоразрядной целочисленной арифметики.

Из алгоритма <<Перечисление по терминальным поддеревьям>> следует, что в формуле с левой частью $F[i,H]$ второй индекс каждого слагаемого в правой части  $\leq H$.

Если в в.р.ф. $R$ присутствует формула с левой частью $F[i,H]$, содержащая в правой части слагаемое $F[j,H]$ с тем же вторым индексом, то будем говорить, что \textit{ формула $j$ предшествует формуле $i$}. Для организации вычислений по в.р.ф. $R$ <<сверху вниз>> требуется упорядочить $R$ таким образом, чтобы соблюдалось условие: если для пары формул $i$ и $j$ известно, что $j$ предшествует $i$, то в упорядочении $R$ формула $j$ встречается раньше, нежели формула $i$. Задачу такого упорядочения будем называть \textit{ задачей согласования в.р.ф}.

\label{the6}
В в.р.ф. $R$ отсутствуют циклические ссылки.


Напомним известное утверждение о \textit{ топологической сортировке}
\cite{akm_13}.

\label{the7}
Вершины ациклического ориентированного графа $G$ на $n$ вершинах можно таким образом пометить числами из множества $\{0, 1, \dots, n-1\}$, что если в графе $G$ имеется дуга $(i,j)$, то $i<j$.


Напомним суть алгоритма топологической сортировки \cite{akm_13}. Произвольно выбранная вершина с нулевой полустепенью исхода помечивается числом $n-1$ и удаляется из графа; в полученном графе произвольная вершина с нулевой полустепенью исхода помечивается числом $n-2$ и удаляется. Процедура повторяется, пока не пометим все вершины.

\label{the8}
Согласование в.р.ф. $R$ всегда выполнимо.


\begin{remark} Задача топологической сортировки текстуально близка к задаче поиска ориентированного гамильтонова пути в каждой компоненте ориентированного графа. В общем случае задача о гамильтоновом пути NP-полна \cite{akm_14}, но для ациклических ориентированных графов задача об ориентированном гамильтоновом пути разрешима за полиномиальное время
\cite{akm_15}. Заметим также, что ориентированный граф имеет цикл в том и только в том случае, когда алгоритм поиска в глубину \cite{akm_16} находит обратную дугу.

Об оценке вычислительной сложности процедуры согласования списка в.р.ф. см. \cite{akm_17}.
\end{remark}






\section{
Примеры вычислений %(вместо заключения)
}

Компьютерные преобразования подтверждают следующую гипотезу (проверка выполнена для $w\leq 13$).
\par\smallskip
\textbf{ Гипотеза (о шаге в.р.ф.)}. \textit{ Сгенерированные алгоритмом <<Перечисление по терминальным поддеревьям>> и согласованные алгоритмом топологической сортировки в.р.ф. являются $3$-согласованными взаимно-рекуррентными формулами.}
\par\smallskip
Из гипотезы следует, что для организации вычислений по сгенерированным согласованным в.р.ф. достаточно инициализировать по три начальных значения каждого из $F[i]$.  Приведем примеры вычислений значений $f(h,w)$.
\par\smallskip
{\small
\noindent 1) $f(3,2)=3$,\\
2) $f(2,4) = 5$,\\
3) $f(20,3)=413403$,\\
4) $f(100,5)=4995246427425596587926101947511568142197556312989986399$, \\
5) $f(8,6)=167089$,\\
6) $f(30,7) = 744382189686310539093281$.
} 